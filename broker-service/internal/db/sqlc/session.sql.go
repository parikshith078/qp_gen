// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: session.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
)

const getUserIDBySessionToken = `-- name: GetUserIDBySessionToken :one
SELECT u.id 
FROM users u
JOIN session_tokens st ON u.id = st.user_id
WHERE st.token = $1 
  AND st.expires_at > CURRENT_TIMESTAMP
LIMIT 1
`

func (q *Queries) GetUserIDBySessionToken(ctx context.Context, token string) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, getUserIDBySessionToken, token)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const markCSRFTokenUsed = `-- name: MarkCSRFTokenUsed :exec
UPDATE csrf_tokens
SET used = true
WHERE token = $1
  AND used = false
  AND expires_at > CURRENT_TIMESTAMP
`

func (q *Queries) MarkCSRFTokenUsed(ctx context.Context, token string) error {
	_, err := q.db.Exec(ctx, markCSRFTokenUsed, token)
	return err
}

const validateCSRFToken = `-- name: ValidateCSRFToken :one
SELECT EXISTS (
  SELECT 1 
  FROM csrf_tokens ct
  JOIN session_tokens st ON ct.session_id = st.id
  WHERE ct.token = $1 
    AND st.token = $2
    AND ct.used = false
    AND ct.expires_at > CURRENT_TIMESTAMP
) AS is_valid
`

type ValidateCSRFTokenParams struct {
	Token   string `json:"token"`
	Token_2 string `json:"token_2"`
}

func (q *Queries) ValidateCSRFToken(ctx context.Context, arg ValidateCSRFTokenParams) (bool, error) {
	row := q.db.QueryRow(ctx, validateCSRFToken, arg.Token, arg.Token_2)
	var is_valid bool
	err := row.Scan(&is_valid)
	return is_valid, err
}

const validateSessionAndCSRFToken = `-- name: ValidateSessionAndCSRFToken :one
SELECT u.id AS user_id
FROM users u
JOIN session_tokens st ON u.id = st.user_id
JOIN csrf_tokens ct ON st.id = ct.session_id
WHERE st.token = $1
  AND ct.token = $2
  AND st.expires_at > CURRENT_TIMESTAMP
  AND ct.expires_at > CURRENT_TIMESTAMP
  AND ct.used = false
LIMIT 1
`

type ValidateSessionAndCSRFTokenParams struct {
	Token   string `json:"token"`
	Token_2 string `json:"token_2"`
}

func (q *Queries) ValidateSessionAndCSRFToken(ctx context.Context, arg ValidateSessionAndCSRFTokenParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, validateSessionAndCSRFToken, arg.Token, arg.Token_2)
	var user_id uuid.UUID
	err := row.Scan(&user_id)
	return user_id, err
}

const validateSessionToken = `-- name: ValidateSessionToken :one
SELECT EXISTS (
  SELECT 1 
  FROM session_tokens 
  WHERE token = $1 
    AND expires_at > CURRENT_TIMESTAMP
) AS is_valid
`

func (q *Queries) ValidateSessionToken(ctx context.Context, token string) (bool, error) {
	row := q.db.QueryRow(ctx, validateSessionToken, token)
	var is_valid bool
	err := row.Scan(&is_valid)
	return is_valid, err
}
